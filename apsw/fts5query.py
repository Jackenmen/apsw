# Process FTS5 queries as documented at https://www.sqlite.org/fts5.html#full_text_query_syntax

# The actual Lemon grammar used is at
# https://sqlite.org/src/file?name=ext/fts5/fts5parse.y

# Tokens https://sqlite.org/src/file?name=ext/fts5/fts5_expr.c
# fts5ExprGetToken

import enum


class FTS5(enum.Enum):
    # these are assigned the same values as generated by
    # lemon, because why not.  fts5parse.h
    EOF = 0
    OR = 1
    AND = 2
    NOT = 3
    TERM = 4
    COLON = 5
    MINUS = 6
    LCP = 7
    RCP = 8
    STRING = 9
    LP = 10
    RP = 11
    CARET = 12
    COMMA = 13
    PLUS = 14
    STAR = 15
    # Add our own
    NEAR = 16


single_char_tokens = {
    "(": FTS5.LP,
    ")": FTS5.RP,
    "{": FTS5.LCP,
    "}": FTS5.RCP,
    ":": FTS5.COLON,
    ",": FTS5.COMMA,
    "+": FTS5.PLUS,
    "*": FTS5.STAR,
    "-": FTS5.MINUS,
    "^": FTS5.CARET,
}

# case sensitive
special_words = {
    "OR": FTS5.OR,
    "NOT": FTS5.NOT,
    "AND": FTS5.AND,
    "NEAR": FTS5.NEAR,
}


def get_tokens(query: str) -> list[tuple[FTS5, str | None]]:
    def skip_spacing():
        "Return True if we skipped any spaces"
        nonlocal pos
        original_pos = pos
        # fts5ExprIsspace
        while query[pos] in " \t\n\r":
            pos += 1
            if pos == len(query):
                return True

        return pos != original_pos

    def absorb_quoted():
        nonlocal pos
        if query[pos] != '"':
            return False

        # two quotes in a row keeps one and continues string
        start = pos + 1
        while True:
            pos = query.index('"', pos + 1)
            if query[pos : pos + 2] == '""':
                pos += 1
                continue
            break
        res.append((FTS5.STRING, query[start:pos].replace('""', '"')))
        pos += 1
        return True

    def absorb_bareword():
        nonlocal pos
        start = pos

        while pos < len(query):
            # sqlite3Fts5IsBareword
            if (
                query[pos] in "0123456789_ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\x1a"
                or ord(query[pos]) >= 0x80
            ):
                pos += 1
            else:
                break
        if pos != start:
            s = query[start:pos]
            res.append((special_words.get(s, FTS5.STRING), s))
            return True
        return False

    res: list[tuple[FTS5, str | None]] = []
    pos = 0

    while pos < len(query):
        if skip_spacing():
            continue
        tok = single_char_tokens.get(query[pos])
        if tok is not None:
            res.append((tok, None))
            pos += 1
            continue

        if absorb_quoted():
            continue

        if absorb_bareword():
            continue

        raise ValueError(f"Invalid query character '{query[pos]}' in '{query}' at {pos=}")

    # fts5 promotes STRING "NEAR" to token NEAR only if followed by "("
    # we demote to get the same effect
    for i in range(len(res) - 1):
        if res[i][0] == FTS5.NEAR and res[i + 1][0] != FTS5.LP:
            res[i] = (FTS5.STRING, "NEAR")

    return res
