# Process FTS5 queries as documented at https://www.sqlite.org/fts5.html#full_text_query_syntax

# The actual Lemon grammar used is at
# https://sqlite.org/src/file?name=ext/fts5/fts5parse.y

# Tokens https://sqlite.org/src/file?name=ext/fts5/fts5_expr.c
# fts5ExprGetToken

from __future__ import annotations

import enum
import dataclasses

from typing import Literal


class FTS5(enum.Enum):
    # these are assigned the same values as generated by
    # lemon, because why not.  fts5parse.h
    EOF = 0
    OR = 1
    AND = 2
    NOT = 3
    TERM = 4
    COLON = 5
    MINUS = 6
    LCP = 7
    RCP = 8
    STRING = 9
    LP = 10
    RP = 11
    CARET = 12
    COMMA = 13
    PLUS = 14
    STAR = 15
    # Add our own
    NEAR = 16


single_char_tokens = {
    "(": FTS5.LP,
    ")": FTS5.RP,
    "{": FTS5.LCP,
    "}": FTS5.RCP,
    ":": FTS5.COLON,
    ",": FTS5.COMMA,
    "+": FTS5.PLUS,
    "*": FTS5.STAR,
    "-": FTS5.MINUS,
    "^": FTS5.CARET,
}

# case sensitive
special_words = {
    "OR": FTS5.OR,
    "NOT": FTS5.NOT,
    "AND": FTS5.AND,
    "NEAR": FTS5.NEAR,
}


@dataclasses.dataclass
class Token:
    tok: FTS5
    pos: int
    value: str | None = None


def get_tokens(query: str) -> list[Token]:
    def skip_spacing():
        "Return True if we skipped any spaces"
        nonlocal pos
        original_pos = pos
        # fts5ExprIsspace
        while query[pos] in " \t\n\r":
            pos += 1
            if pos == len(query):
                return True

        return pos != original_pos

    def absorb_quoted():
        nonlocal pos
        if query[pos] != '"':
            return False

        # two quotes in a row keeps one and continues string
        start = pos + 1
        while True:
            pos = query.index('"', pos + 1)
            if query[pos : pos + 2] == '""':
                pos += 1
                continue
            break
        res.append(Token(FTS5.STRING, start, query[start:pos].replace('""', '"')))
        pos += 1
        return True

    def absorb_bareword():
        nonlocal pos
        start = pos

        while pos < len(query):
            # sqlite3Fts5IsBareword
            if (
                query[pos] in "0123456789_ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\x1a"
                or ord(query[pos]) >= 0x80
            ):
                pos += 1
            else:
                break
        if pos != start:
            s = query[start:pos]
            res.append(Token(special_words.get(s, FTS5.STRING), start, s))
            return True
        return False

    res: list[Token] = []
    pos = 0

    while pos < len(query):
        if skip_spacing():
            continue
        tok = single_char_tokens.get(query[pos])
        if tok is not None:
            res.append(Token(tok, pos))
            pos += 1
            continue

        if absorb_quoted():
            continue

        if absorb_bareword():
            continue

        raise ValueError(f"Invalid query character '{query[pos]}' in '{query}' at {pos=}")

    # fts5 promotes STRING "NEAR" to token NEAR only if followed by "("
    # we demote to get the same effect
    for i in range(len(res) - 1):
        if res[i].tok == FTS5.NEAR and res[i + 1].tok != FTS5.LP:
            res[i].tok = FTS5.STRING

    # two adjacent string are implicitly anded - make that explicit
    for i in range(len(res) - 2, -1, -1):
        if res[i].tok == FTS5.STRING and res[i + 1].tok == FTS5.STRING:
            res.insert(i + 1, Token(FTS5.AND, res[i + 1].pos))

    # add explicit EOF
    res.append(Token(FTS5.EOF, pos))
    return res


class Operation(enum.Enum):
    "How the phrases are treated"

    AND = enum.auto()
    "All must occur, in any order"
    OR = enum.auto()
    "At least one must occur"
    NOT = enum.auto()
    "None must be present"
    NEAR = enum.auto()
    "Must be near each other"
    SEQUENCE = enum.auto()
    "All must occur in order"


@dataclasses.dataclass
class Query:
    op: Operation
    phrases: list[str | Query]
    columns: ColumnSpec | None = None
    near_distance: int = -1


@dataclasses.dataclass
class ColumnSpec:
    columns: list[str]
    include: bool = True


class Parse:
    class Error(Exception):
        def __init__(self, message: str, token: Token):
            Exception.__init__(self, message)
            self.token = token

    def show_error(self, query: str, exc: Parse.Error):
        print(query)
        print(" " * exc.token.pos + "^", exc.args[0])
        print(exc.token)

    def __init__(self, query):
        self.tokens = get_tokens(query)
        self.token_num = -1
        try:
            result = self.query()
            if self.lookahead().tok != FTS5.EOF:
                raise Parse.Error("unexpected", self.tokens[self.token_num])
            if isinstance(result, str):
                result = Query(Operation.AND, [result])
            print("\nParse results")
            self.print_query(result)
        except Parse.Error as exc:
            self.show_error(query, exc)
            raise

    def print_query(self, query: Query, indent: int = 0):
        i = "    " * indent
        print(f"{i}{query.op} {'' if query.near_distance==-1 else query.near_distance}")
        if query.columns:
            print(f"{i}{query.columns}")
        for phrase in query.phrases:
            if isinstance(phrase, str):
                print(f'{i}"{phrase}"')
            else:
                self.print_query(phrase, indent + 1)

    def take_token(self) -> Token:
        self.token_num += 1
        return self.tokens[self.token_num]

    def lookahead(self) -> Token:
        return self.tokens[self.token_num + 1]

    def prefix(self) -> Query | str:
        "Handle token as prefix (nud)"
        token = self.take_token()
        if token.tok == FTS5.STRING:
            return token.value
        if token.tok == FTS5.LP:
            query = self.query(0)
            if self.lookahead().tok != FTS5.RP:
                raise self.Error("Did not find matching )", token)
            self.take_token()
            return query
        if token.tok == FTS5.NEAR:
            self.expect(FTS5.LP)
            # we should take PHRASE
            #   PHRASE is STRING and +
            #   AND / OR / NOT not allowed
            # then optional COMMA
            #   then STRING that is number
            # then RP
            1 / 0

        raise self.Error("unexpected", token)

    def infix(self, left: Query) -> Query:
        "Handle token as infix (led)"
        token = self.take_token()
        if token.tok == FTS5.AND:
            right = self.query(self.lbp[token.tok])
            return self.flatten_query(Query(Operation.AND, [left, right]))
        elif token.tok == FTS5.OR:
            right = self.query(self.lbp[token.tok])
            return self.flatten_query(Query(Operation.OR, [left, right]))
        elif token.tok == FTS5.PLUS:
            right = self.query(self.lbp[token.tok])
            return self.flatten_query(Query(Operation.SEQUENCE, [left, right]))
        raise self.Error("unimplemented", token)

    def flatten_query(self, query: Query) -> Query:
        "Simplify if possible"
        # we want to promote child phrases into parent

        def check_phrase(p: str | Query):
            # does str require query.op == AND?
            if isinstance(p, str):
                return True
            return p.op == query.op and p.columns == query.columns and p.near_distance == query.near_distance

        if all(check_phrase(child) for child in query.phrases):
            new_phrases = []
            for phrase in query.phrases:
                if isinstance(phrase, str):
                    new_phrases.append(phrase)
                else:
                    new_phrases.extend(phrase.phrases)
            query.phrases = new_phrases
        return query

    # Any tokens implementing an infix operation (think having a
    # left and right hand side) must have a non-zero value
    lbp = {
        FTS5.OR: 30,
        FTS5.AND: 40,
        FTS5.PLUS: 50,
        FTS5.NOT: 60,
        FTS5.COLON: 70,
    }
    "left binding power"

    def query(self, rbp: int = 0) -> Query | str:
        res = self.prefix()

        while rbp < self.lbp.get(self.lookahead().tok, 0):
            res = self.infix(res)

        return res
