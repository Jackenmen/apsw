# Process FTS5 queries as documented at https://www.sqlite.org/fts5.html#full_text_query_syntax

# The actual Lemon grammar used is at
# https://sqlite.org/src/file?name=ext/fts5/fts5parse.y

# Tokens https://sqlite.org/src/file?name=ext/fts5/fts5_expr.c
# fts5ExprGetToken

from __future__ import annotations

import enum
import dataclasses

from typing import Literal, Any


class FTS5(enum.Enum):
    # these are assigned the same values as generated by
    # lemon, because why not.  fts5parse.h
    EOF = 0
    OR = 1
    AND = 2
    NOT = 3
    TERM = 4
    COLON = 5
    MINUS = 6
    LCP = 7
    RCP = 8
    STRING = 9
    LP = 10
    RP = 11
    CARET = 12
    COMMA = 13
    PLUS = 14
    STAR = 15
    # Add our own
    NEAR = 16


single_char_tokens = {
    "(": FTS5.LP,
    ")": FTS5.RP,
    "{": FTS5.LCP,
    "}": FTS5.RCP,
    ":": FTS5.COLON,
    ",": FTS5.COMMA,
    "+": FTS5.PLUS,
    "*": FTS5.STAR,
    "-": FTS5.MINUS,
    "^": FTS5.CARET,
}

# case sensitive
special_words = {
    "OR": FTS5.OR,
    "NOT": FTS5.NOT,
    "AND": FTS5.AND,
    "NEAR": FTS5.NEAR,
}


@dataclasses.dataclass
class Token:
    tok: FTS5
    pos: int
    value: str | None = None


def get_tokens(query: str) -> list[Token]:
    def skip_spacing():
        "Return True if we skipped any spaces"
        nonlocal pos
        original_pos = pos
        # fts5ExprIsspace
        while query[pos] in " \t\n\r":
            pos += 1
            if pos == len(query):
                return True

        return pos != original_pos

    def absorb_quoted():
        nonlocal pos
        if query[pos] != '"':
            return False

        # two quotes in a row keeps one and continues string
        start = pos + 1
        while True:
            pos = query.index('"', pos + 1)
            if query[pos : pos + 2] == '""':
                pos += 1
                continue
            break
        res.append(Token(FTS5.STRING, start, query[start:pos].replace('""', '"')))
        pos += 1
        return True

    def absorb_bareword():
        nonlocal pos
        start = pos

        while pos < len(query):
            # sqlite3Fts5IsBareword
            if (
                query[pos] in "0123456789_ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\x1a"
                or ord(query[pos]) >= 0x80
            ):
                pos += 1
            else:
                break
        if pos != start:
            s = query[start:pos]
            res.append(Token(special_words.get(s, FTS5.STRING), start, s))
            return True
        return False

    res: list[Token] = []
    pos = 0

    while pos < len(query):
        if skip_spacing():
            continue
        tok = single_char_tokens.get(query[pos])
        if tok is not None:
            res.append(Token(tok, pos))
            pos += 1
            continue

        if absorb_quoted():
            continue

        if absorb_bareword():
            continue

        raise ValueError(f"Invalid query character '{query[pos]}' in '{query}' at {pos=}")

    # fts5 promotes STRING "NEAR" to token NEAR only if followed by "("
    # we demote to get the same effect
    for i in range(len(res) - 1):
        if res[i].tok == FTS5.NEAR and res[i + 1].tok != FTS5.LP:
            res[i].tok = FTS5.STRING

    # add explicit EOF
    res.append(Token(FTS5.EOF, pos))
    return res


@dataclasses.dataclass
class PHRASES:
    "phrases"

    phrases: list[PHRASE]
    initial: bool = False
    "if true then phrase must match first token in column"


@dataclasses.dataclass
class PHRASE:
    "one phrase"

    phrase: str
    prefix: bool = False
    "if True then if it is a prefix search"
    sequence: bool = False
    "if True must follow tokens of previous phrase"


@dataclasses.dataclass
class NEAR:
    "near operation"

    phrases: PHRASES
    distance: int


@dataclasses.dataclass
class COLUMNFILTER:
    "limit query to columns"

    columns: list[str]
    query: QUERY
    include: bool


@dataclasses.dataclass
class AND:
    "all queries must match"

    queries: list[QUERY]


@dataclasses.dataclass
class OR:
    "any query must match"

    queries: list[QUERY]


@dataclasses.dataclass
class NOT:
    "left must match but right must not"

    left: QUERY
    right: QUERY


QUERY = COLUMNFILTER | NEAR | AND | OR | NOT | PHRASES


def to_dict(q: QUERY | PHRASE) -> dict[str, Any]:
    if isinstance(q, PHRASES):
        res = {"op": "phrases"}
        if q.initial:
            res["initial"] = q.initial
        res["phrases"] = [to_dict(phrase) for phrase in q.phrases]
        return res

    if isinstance(q, PHRASE):
        res = {"op": "phrase", "phrase": q.phrase}
        if q.prefix:
            res["prefix"] = True
        if q.sequence:
            res["sequence"] = True
        return res

    if isinstance(q, AND):
        return {"op": "and", "queries": [to_dict(query) for query in q.queries]}

    if isinstance(q, OR):
        return {"op": "or", "queries": [to_dict(query) for query in q.queries]}

    if isinstance(q, NOT):
        return {"op": "not", "true": q.left, "false": q.right}

    if isinstance(q, NEAR):
        res = {"op": "near", "phrases": to_dict(q.phrases)}
        if q.distance != 10:
            res["distance"] = q.distance
        return res

    if isinstance(q, COLUMNFILTER):
        return {"op": "columnfilter", "columns": q.columns, "include": q.include, "query": to_dict(q.query)}

    raise NotImplementedError(f"{q=}")


class Parse:
    class Error(Exception):
        def __init__(self, message, token):
            self.message = message
            self.token = token

    def __init__(self, query: str):
        self.tokens = get_tokens(query)
        self.token_pos = -1

        try:
            result = self.parse_query()
            if self.lookahead.tok != FTS5.EOF:
                raise Parse.Error("unexpected", self.lookahead)
        except Parse.Error as exc:
            print(query)
            print(" " * exc.token.pos + "\u2b06 " + exc.message)
            raise

        import pprint

        pprint.pprint(to_dict(result))

    def _lookahead(self) -> Token:
        return self.tokens[self.token_pos + 1]

    lookahead = property(_lookahead, doc="Lookahead at next token")

    def take_token(self) -> Token:
        self.token_pos += 1
        return self.tokens[self.token_pos]

    def parse_part(self) -> QUERY:
        if self.lookahead.tok in {FTS5.MINUS, FTS5.LCP} or (
            self.lookahead.tok == FTS5.STRING and self.tokens[self.token_pos + 2].tok == FTS5.COLON
        ):
            return self.parse_colspec()

        if self.lookahead.tok == FTS5.LP:
            token = self.take_token()
            query = self.parse_query()
            if self.lookahead.tok != FTS5.RP:
                raise Parse.Error("unclosed (", token)
            self.take_token()
            return query

        if self.lookahead.tok == FTS5.NEAR:
            return self.parse_near()

        return self.parse_phrases()

    infix_precedence = {
        FTS5.OR: 10,
        FTS5.AND: 20,
        FTS5.NOT: 30,
    }

    def parse_query(self, rbp: int = 0):
        res = self.parse_part()

        while rbp < self.infix_precedence.get(self.lookahead.tok, 0):
            token = self.take_token()
            res = self.infix(token.tok, res, self.parse_query(self.infix_precedence[token.tok]))

        return res

    def parse_phrase(self) -> PHRASE:
        token = self.take_token()
        if token.tok != FTS5.STRING:
            raise self.Error("Expected a search term", token)

        res = PHRASE(token.value)

        if self.lookahead.tok == FTS5.STAR:
            self.take_token()
            res.prefix = True

        return res

    def parse_phrases(self) -> PHRASES:
        if self.lookahead.tok not in {FTS5.CARET, FTS5.STRING}:
            raise self.Error("Expected '^' or a search term", self.lookahead)

        if self.lookahead.tok == FTS5.CARET:
            initial = True
            self.take_token()
        else:
            initial = False

        first = self.parse_phrase()

        res = PHRASES([first], initial)

        while self.lookahead.tok in {FTS5.PLUS, FTS5.STRING}:
            if self.lookahead.tok == FTS5.PLUS:
                self.take_token()
                sequence = True
            else:
                sequence = False
            res.phrases.append(self.parse_phrase())
            if sequence:
                res.phrases[-1].sequence = True

        return res

    def parse_near(self):
        # swallow NEAR
        self.take_token()

        # open parentheses
        token = self.take_token()
        if token.tok != FTS5.LP:
            raise self.Error("Expected '(", token)

        # phrases
        phrases = self.parse_phrases()

        # , distance
        distance = 10  # default
        if self.lookahead.tok == FTS5.COMMA:
            # absorb comma
            self.take_token()
            # distance
            number = self.take_token()
            if number.tok != FTS5.STRING or not number.value.isdigit():
                raise self.Error("Expected number", number)
            distance = int(number.value)

        # close parentheses
        if self.lookahead.tok != FTS5.RP:
            raise self.Error("Expected )")
        self.take_token()

        return NEAR(phrases, distance)

    def parse_colspec(self):
        include = True
        columns = []
        if self.lookahead.tok == FTS5.MINUS:
            include = False
            self.take_token()
        # inside curlys?
        if self.lookahead.tok == FTS5.LCP:
            self.take_token()
            while self.lookahead.tok == FTS5.STRING:
                columns.append(self.take_token().value)
            if len(columns) == 0:
                raise self.Error("Expected column name", self.lookahead)
            if self.lookahead.tok != FTS5.RCP:
                raise self.Error("Expected }", self.lookahead)
            self.take_token()
        else:
            if self.lookahead.tok != FTS5.STRING:
                raise self.Error("Expected column name", self.lookahead)
            columns.append(self.take_token().value)
        if self.lookahead.tok != FTS5.COLON:
            raise self.Error("Expected :", self.lookahead)
        self.take_token()

        if self.lookahead.tok == FTS5.LP:
            query = self.parse_query()
        elif self.lookahead.tok == FTS5.NEAR:
            query = self.parse_part()
        else:
            query = self.parse_phrases()

        return COLUMNFILTER(columns, query, include)

    def infix(self, op: FTS5, left: QUERY, right: QUERY) -> QUERY:
        if op == FTS5.NOT:
            return NOT(left, right)
        klass = {FTS5.AND: AND, FTS5.OR: OR}[op]
        if isinstance(left, klass):
            left.queries.append(right)
            return left
        return klass([left, right])
