# Process FTS5 queries as documented at https://www.sqlite.org/fts5.html#full_text_query_syntax

# The actual Lemon grammar used is at
# https://sqlite.org/src/file?name=ext/fts5/fts5parse.y

# Tokens https://sqlite.org/src/file?name=ext/fts5/fts5_expr.c
# fts5ExprGetToken

from __future__ import annotations

import enum
import dataclasses

from typing import Literal


class FTS5(enum.Enum):
    # these are assigned the same values as generated by
    # lemon, because why not.  fts5parse.h
    EOF = 0
    OR = 1
    AND = 2
    NOT = 3
    TERM = 4
    COLON = 5
    MINUS = 6
    LCP = 7
    RCP = 8
    STRING = 9
    LP = 10
    RP = 11
    CARET = 12
    COMMA = 13
    PLUS = 14
    STAR = 15
    # Add our own
    NEAR = 16


single_char_tokens = {
    "(": FTS5.LP,
    ")": FTS5.RP,
    "{": FTS5.LCP,
    "}": FTS5.RCP,
    ":": FTS5.COLON,
    ",": FTS5.COMMA,
    "+": FTS5.PLUS,
    "*": FTS5.STAR,
    "-": FTS5.MINUS,
    "^": FTS5.CARET,
}

# case sensitive
special_words = {
    "OR": FTS5.OR,
    "NOT": FTS5.NOT,
    "AND": FTS5.AND,
    "NEAR": FTS5.NEAR,
}


@dataclasses.dataclass
class Token:
    tok: FTS5
    pos: int
    value: str | None = None


def get_tokens(query: str) -> list[Token]:
    def skip_spacing():
        "Return True if we skipped any spaces"
        nonlocal pos
        original_pos = pos
        # fts5ExprIsspace
        while query[pos] in " \t\n\r":
            pos += 1
            if pos == len(query):
                return True

        return pos != original_pos

    def absorb_quoted():
        nonlocal pos
        if query[pos] != '"':
            return False

        # two quotes in a row keeps one and continues string
        start = pos + 1
        while True:
            pos = query.index('"', pos + 1)
            if query[pos : pos + 2] == '""':
                pos += 1
                continue
            break
        res.append(Token(FTS5.STRING, start, query[start:pos].replace('""', '"')))
        pos += 1
        return True

    def absorb_bareword():
        nonlocal pos
        start = pos

        while pos < len(query):
            # sqlite3Fts5IsBareword
            if (
                query[pos] in "0123456789_ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\x1a"
                or ord(query[pos]) >= 0x80
            ):
                pos += 1
            else:
                break
        if pos != start:
            s = query[start:pos]
            res.append(Token(special_words.get(s, FTS5.STRING), start, s))
            return True
        return False

    res: list[Token] = []
    pos = 0

    while pos < len(query):
        if skip_spacing():
            continue
        tok = single_char_tokens.get(query[pos])
        if tok is not None:
            res.append(Token(tok, pos))
            pos += 1
            continue

        if absorb_quoted():
            continue

        if absorb_bareword():
            continue

        raise ValueError(f"Invalid query character '{query[pos]}' in '{query}' at {pos=}")

    # fts5 promotes STRING "NEAR" to token NEAR only if followed by "("
    # we demote to get the same effect
    for i in range(len(res) - 1):
        if res[i].tok == FTS5.NEAR and res[i + 1].tok != FTS5.LP:
            res[i].tok = FTS5.STRING

    # two adjacent string are implicitly anded - make that explicit
    for i in range(len(res) - 2, -1, -1):
        if res[i].tok == FTS5.STRING and res[i + 1].tok == FTS5.STRING:
            res.insert(i + 1, Token(FTS5.AND, res[i + 1].pos))

    # add explicit EOF
    res.append(Token(FTS5.EOF, pos))
    return res


class Operation(enum.Enum):
    "How the phrases are treated"

    AND = enum.auto()
    "All must occur, in any order"
    OR = enum.auto()
    "At least one must occur"
    NOT = enum.auto()
    "None must be present"
    NEAR = enum.auto()
    "Must be near each other"
    SEQUENCE = enum.auto()
    "All must occur in order"


@dataclasses.dataclass
class Query:
    op: Operation
    phrases: list[str | Query]
    columns_included: list[str] | None = None
    columns_excluded: list[str] | None = None
    near_distance: int = -1


class Parse:
    class Error(Exception):
        def __init__(self, message: str, token: Token):
            Exception.__init__(self, message)
            self.token = token

    def show_error(self, query: str, exc: Parse.Error):
        print(query)
        print(" " * exc.token.pos + "^", exc.args[0])
        print(exc.token)

    def __init__(self, query):
        self.tokens = get_tokens(query)
        self.token_num = -1
        try:
            result = self.query()
            if self.token_num != len(self.tokens):
                raise Parse.Error("unexpected", self.tokens[self.token_num])
            print(f"{result=}")
        except Parse.Error as exc:
            self.show_error(query, exc)
            raise

    def take_token(self) -> Token:
        self.token_num += 1
        return self.tokens[self.token_num]

    def lookahead(self) -> Token:
        return self.tokens[self.token_num + 1]

    def prefix(self):
        "Handle token as prefix (nud)"
        token = self.take_token()
        if token.tok == FTS5.STRING:
            return Query("AND", [token.value])
        if token.tok == FTS5.NEAR:
            # tokenizer takes care of open paren
            assert self.lookahead().tok == FTS5.LP
            self.take_token()
            # FTS5 parser has special grammar for nearset and nearphrase
            # to reject OR / NOT
            phrases = self.query(0)
            1 / 0

        raise self.Error("unexpected", token)

    def infix(self, left: Query) -> Query:
        "Handle token as infix (led)"
        token = self.take_token()
        if token.tok == FTS5.AND:
            right = self.query(self.lbp[token.tok])
            1 / 0
        elif token.tok == FTS5.PLUS:
            right = self.query(self.lbp[token.tok])
            1 / 0
        raise self.Error("unimplemented", token)

    # Any tokens implementing an infix operation (think having a
    # left and right hand side) must have a non-zero value
    lbp = {
        FTS5.OR: 30,
        FTS5.AND: 40,
        FTS5.PLUS: 50,
        FTS5.NOT: 60,
        FTS5.COLON: 70,
    }
    "left binding power"

    def query(self, rbp: int = 0):
        res = self.prefix()

        while rbp < self.lbp.get(self.lookahead().tok, 0):
            res = self.infix(res)

        return res
