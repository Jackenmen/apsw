#!/usr/bin/env python3

# See the accompanying LICENSE file.
"""This file runs the test suite against several versions of SQLite
and Python to make sure everything is ok in the various combinations.
It only runs on a UNIX like environment.

All the work is done in parallel rather than serially.  This allows
for it to finish a lot sooner.

"""

import os
import sys
import threading
import queue
import optparse
import traceback
import re

os.chdir(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

# disable testfileprefix
os.putenv("APSWTESTPREFIX", "")
try:
    del os.environ["APSWTESTPREFIX"]
except KeyError:
    pass

# make sure all extensions are tested
for e in "fts3", "rtree", "icu":
    os.putenv("APSW_TEST_" + e.upper(), e)


def run(cmd):
    status = os.system(cmd)
    if os.WIFEXITED(status):
        code = os.WEXITSTATUS(status)
        if code == 0:
            return
        raise Exception("Exited with code " + str(code) + ": " + cmd)
    raise Exception("Failed with signal " + str(os.WTERMSIG(status)) + ": " + cmd)


def dotest(pyver, logdir, pybin, pylib, workdir, sqlitever, debug):
    run("set -e ; cd %s ; ( env LD_LIBRARY_PATH=%s APSW_FORCE_DISTUTILS=t %s setup.py fetch --version=%s --all build_test_extension build_ext --inplace --force --enable-all-extensions%stest -v ) >%s 2>&1"
        % (workdir, pylib, pybin, sqlitever, " --debug " if debug else " ", os.path.abspath(os.path.join(logdir, "buildruntests.txt"))))


def runtest(workdir, pyver, sqlitever, logdir, debug):
    pybin, pylib = buildpython(workdir, pyver, os.path.abspath(os.path.join(logdir, "pybuild.txt")))
    dotest(pyver, logdir, pybin, pylib, workdir, sqlitever, debug)


def threadrun(queue):
    while True:
        d = queue.get()
        if d is None:
            return
        try:
            runtest(**d)
            sys.stdout.write(".")
            sys.stdout.flush()
        except:
            # uncomment to debug problems with this script
            # traceback.print_exc()
            print("\nFAILED", d)


def main(PYVERS, SQLITEVERS, concurrency):
    try:
        del os.environ["APSWTESTPREFIX"]
    except KeyError:
        pass
    print("Test starting")
    os.system("rm -rf apsw.so megatestresults 2>/dev/null ; mkdir megatestresults")
    print("  ... removing old work directory")
    workdir = os.path.abspath("work")
    os.system("rm -rf %s/* 2>/dev/null ; mkdir -p %s" % (workdir, workdir))
    os.system("rm -f src/shell.c")  # autogenerated
    os.system('rm -rf $HOME/.local/lib/python*/site-packages/apsw* 2>/dev/null')
    print("      done")

    q = queue.Queue()
    threads = []

    for pyver in PYVERS:
            for sqlitever in SQLITEVERS:
                for debug in False, True:
                    print("Python", pyver, "   SQLite", sqlitever, "  debug", debug)
                    workdir = os.path.abspath(os.path.join("work", "py%s-sq%s%s" % (pyver, sqlitever, "-debug" if debug else "")))
                    logdir = os.path.abspath(os.path.join("megatestresults", "py%s-sq%s%s" % (pyver, sqlitever,"-debug" if debug else "")))
                    run("mkdir -p %s/src %s/tools %s" % (workdir, workdir, logdir))
                    run("cp *.py checksums " + workdir)
                    run("cp tools/*.py " + workdir + "/tools/")
                    run("cp src/*.c src/*.h " + workdir + "/src/")

                    q.put({'workdir': workdir, 'pyver': pyver, 'sqlitever': sqlitever, 'logdir': logdir, "debug": debug})

    threads = []
    for i in range(concurrency):
        q.put(None)  # exit sentinel
        t = threading.Thread(target=threadrun, args=(q, ))
        t.start()
        threads.append(t)

    print("All builds started, now waiting for them to finish (%d concurrency)" % (concurrency, ))
    for t in threads:
        t.join()
    print("\nFinished")


def getpyurl(pyver):
    dirver = pyver
    if 'a' in dirver:
        dirver = dirver.split('a')[0]
    elif 'b' in dirver:
        dirver = dirver.split('b')[0]
    elif 'rc' in dirver:
        dirver = dirver.split('rc')[0]

    # Upper or lower case 'p' in download filename is somewhat random
    p = 'P'
    ext = "xz"
    return "https://www.python.org/ftp/python/%s/%sython-%s.tar.%s" % (dirver, p, pyver, ext)


def buildpython(workdir, pyver, logfilename):
    if pyver == "system": return "/usr/bin/python3", ""
    url = getpyurl(pyver)
    tarx = "J"
    run("set -e ; cd %s ; mkdir pyinst ; ( echo \"Getting %s\"; wget -q %s -O - | tar xf%s -  ) > %s 2>&1" %
        (workdir, url, url, tarx, logfilename))
    opt = ''
    full = ""
    if sys.platform.startswith("linux"):
        ldflags = "LDFLAGS=\"-L/usr/lib/$(dpkg-architecture -qDEB_HOST_MULTIARCH)\"; export LDFLAGS;"
    else:
        ldflags = ""
    run("set -e ; %s cd %s ; cd ?ython-%s ; ./configure %s --prefix=%s/pyinst  >> %s 2>&1; make >>%s 2>&1; make  %sinstall >>%s 2>&1 ; make clean >/dev/null"
        % (ldflags, workdir, pyver, opt, workdir, logfilename, logfilename, full, logfilename))
    suf = "3"
    pybin = os.path.join(workdir, "pyinst", "bin", "python" + suf)
    return pybin, os.path.join(workdir, "pyinst", "lib")


def natural_compare(a, b):
    # https://stackoverflow.com/a/8408177
    convert = lambda text: int(text) if text.isdigit() else text.lower()
    alphanum_key = lambda key: [convert(c) for c in re.split('([0-9]+)', key)]

    return cmp(alphanum_key(a), alphanum_key(b))


def cmp(a, b):
    if a < b:
        return -1
    if a > b:
        return +1
    assert a == b
    return 0

# Default versions we support
PYVERS = (
    '3.10.1',
    '3.9.9',
    '3.8.10',
    '3.7.10',
    'system',
)

SQLITEVERS = ('3.37.0', )

if __name__ == '__main__':
    nprocs = 0
    try:
        # try and work out how many processors there are - this works on linux
        for line in open("/proc/cpuinfo", "rt"):
            line = line.split()
            if line and line[0] == "processor":
                nprocs += 1
    except:
        pass
    # well there should be at least one!
    if nprocs == 0:
        nprocs = 1

    concurrency = nprocs * 2
    if concurrency > 24:
        concurrency = 24

    parser = optparse.OptionParser()
    parser.add_option("--pyvers",
                      dest="pyvers",
                      help="Which Python versions to test against [%default]",
                      default=",".join(PYVERS))
    parser.add_option("--sqlitevers",
                      dest="sqlitevers",
                      help="Which SQLite versions to test against [%default]",
                      default=",".join(SQLITEVERS))
    parser.add_option("--fossil",
                      dest="fossil",
                      help="Also test current SQLite FOSSIL version [%default]",
                      default=False,
                      action="store_true")
    parser.add_option("--tasks",
                      dest="concurrency",
                      help="Number of simultaneous builds/tests to run [%default]",
                      default=concurrency)

    options, args = parser.parse_args()

    if args:
        parser.error("Unexpected options " + str(options))

    pyvers = options.pyvers.split(",")
    sqlitevers = options.sqlitevers.split(",")
    if options.fossil:
        sqlitevers.append("fossil")
    concurrency = int(options.concurrency)
    sqlitevers = [x for x in sqlitevers if x]
    main(pyvers, sqlitevers, concurrency)
