#!/usr/bin/env python3

# Generates code from unicode properties db


import sys
import itertools
import time

try:
    batched = itertools.batched
except AttributeError:
    # Copied from https://docs.python.org/3/library/itertools.html#itertools.batched
    def batched(iterable, n):
        # batched('ABCDEFG', 3) --> ABC DEF G
        if n < 1:
            raise ValueError("n must be at least one")
        it = iter(iterable)
        while batch := tuple(itertools.islice(it, n)):
            yield batch

def is_one_value(vals):
    return len(vals) == 1 and isinstance(vals[0], int)

def is_one_range(vals):
    return len(vals) == 1 and not isinstance(vals[0], int)

def all_vals(vals):
    for row in vals:
        if isinstance(row, int):
            yield row
        else:
            yield from range(row[0], row[1])

def fmt(v: int) -> str:
    # format values the same as in the text source for easy grepping
    return "0x%04X" % v

# We do Python code for testing and development
def generate_python() -> str:
    out: list[str] = []
    for top in props:
        for name, vals in sorted(props[top].items()):
            if is_one_value(vals):
                out.append(f"def is_{top}_{name}(c: int) -> bool:")
                out.append(f"   return c == { fmt(vals[0])}")
            elif is_one_range(vals):
                out.append(f"def is_{top}_{name}(c: int) -> bool:")
                out.append(f"   return { fmt(vals[0][0]) } <= c <= { fmt(vals[0][1]) }")
            else:
                out.append(f"_{ top }_{ name }_members = {{")
                for row in batched(all_vals(vals), 10):
                    out.append("    " + ", ".join(fmt(v) for v in row) + ",")
                out.append("}")
                out.append("")
                out.append(f"def is_{top}_{name}(c: int) -> bool:")
                out.append(f"   return c in _{ top }_{ name }_members")
            out.append("")
            out.append("")

    return "\n".join(out) + "\n"


props = {
    "grapheme": {},
    "word": {},
    "sentence": {},
}


def populate(source: str, dest: dict[str, list]):
    for line in source.splitlines():
        if not line.strip() or line.startswith("#"):
            continue
        line = line.split(";", 2)
        label = line[1].split()[0].strip()
        try:
            accumulate = dest[label]
        except KeyError:
            accumulate = dest[label] = []

        vals = line[0].strip().split("..")
        start = int(vals[0], 16)
        if len(vals) == 1:
            accumulate.append(start)
        else:
            end = int(vals[1], 16)
            accumulate.append((start, end))


def read_props(ucd_base: str):
    for top in "Grapheme", "Word", "Sentence":
        url = f"{ucd_base}{ top }BreakProperty.txt"
        print("Reading", url)
        source = urllib.request.urlopen(url).read().decode("utf8")
        populate(source, props[top.lower()])

py_code_header = f"""
# Generated by { sys.argv[0] } on { time.asctime() }

# Do not edit

"""

if __name__ == "__main__":
    import argparse
    import urllib.request

    p = argparse.ArgumentParser(description="Generate code from Unicode properties")
    p.add_argument(
        "--ucd-base",
        default="https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/",
        help="Base for properties file [%(default)s]",
    )
    p.add_argument("out_py", type=argparse.FileType("w", encoding="utf8"), help="File to write python code to")

    options = p.parse_args()

    read_props(options.ucd_base)

    py_code = generate_python()
    options.out_py.write(py_code_header)
    options.out_py.write(py_code)
    options.out_py.close()
