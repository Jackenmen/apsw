#!/usr/bin/python

proto = """
static int
APSW_FaultInjectControl(const char *faultfunction, const char *filename, const char *funcname, int linenum, const char *args, PyObject **obj);

/* these are needed because we don't want to fault within our faulting */

static long PyLong_AsLong_fi(PyObject *obj) { return PyLong_AsLong(obj);}
static const char *PyUnicode_AsUTF8_fi(PyObject *obj) { return PyUnicode_AsUTF8(obj); }
"""

# this also works for pointer returns that use NULL for error and set a Python exception
# like PyUnicode_AsUTF8
pyobject_return = """
({
    __auto_type _res = 0 ? PySet_New(__VA_ARGS__) : 0;
    PyGILState_STATE gilstate = PyGILState_Ensure();
    switch (APSW_FaultInjectControl("PySet_New", __FILE__, __func__, __LINE__, #__VA_ARGS__, (PyObject**)&_res))
    {
    case 0x1FACADE:
        assert(_res == 0);
        _res = PySet_New(__VA_ARGS__);
        break;
    default:
        assert(_res || PyErr_Occurred());
        assert(!(_res && PyErr_Occurred()));
        break;
    }
    PyGILState_Release(gilstate);
    _res;
})
"""

# for int returns, the fault injection can either return a number
# (PyLong) or a tuple(PyLong, AType, str) in which case
# PyErr_Format(AType, "%s", str) sets Python exception indicator and
# the PyLong is returned


# note this releases the gil around calls.
return_no_gil = """
({
    PyObject *_res2 = 0;
    __auto_type _res = 0 ? sqlite3_threadsafe(__VA_ARGS__) : 0;
    PyGILState_STATE gilstate = PyGILState_Ensure();
    switch (APSW_FaultInjectControl("sqlite3_threadsafe", __FILE__, __func__, __LINE__, #__VA_ARGS__, &_res2))
    {
    case 0x1FACADE:
        assert(_res2 == 0);
        PyGILState_Release(gilstate);
        _res = sqlite3_threadsafe(__VA_ARGS__);
        gilstate = PyGILState_Ensure();
        break;
    default:
        if(!_res2) PyErr_Print();
        assert(_res2);
        if(PyTuple_Check(_res2))
        {
            assert(3 == PyTuple_GET_SIZE(_res2));
            _res = (typeof(_res)) PyLong_AsLong_fi(PyTuple_GET_ITEM(_res2, 0));
            assert(PyUnicode_Check(PyTuple_GET_ITEM(_res2, 2)));
            PyErr_Format(PyTuple_GET_ITEM(_res2, 1), "%s", PyUnicode_AsUTF8_fi(PyTuple_GET_ITEM(_res2, 2)));
        }
        else
        {
            assert(PyLong_Check(_res2));
            _res = PyLong_AsLong_fi(_res2);
        }
        break;
    }
    Py_XDECREF(_res2);
    PyGILState_Release(gilstate);
    _res;
})
"""

return_with_gil = """
({
    PyObject *_res2=0;
    __auto_type _res = 0 ? PyType_Ready(__VA_ARGS__) : 0;
    PyGILState_STATE gilstate = PyGILState_Ensure();
    switch (APSW_FaultInjectControl("PyType_Ready", __FILE__, __func__, __LINE__, #__VA_ARGS__, &_res2))
    {
    case 0x1FACADE:
        assert(_res == 0);
        _res = PyType_Ready(__VA_ARGS__);
        break;
    default:
        if(PyTuple_Check(_res2))
        {
            assert(3 == PyTuple_GET_SIZE(_res2));
            _res =  (typeof(_res)) PyLong_AsLong_fi(PyTuple_GET_ITEM(_res2, 0));
            assert(PyUnicode_Check(PyTuple_GET_ITEM(_res2, 2)));
            PyErr_Format(PyTuple_GET_ITEM(_res2, 1), "%s", PyUnicode_AsUTF8_fi(PyTuple_GET_ITEM(_res2, 2)));
        }
        else
        {
            assert(PyLong_Check(_res2));
            _res = PyLong_AsLong_fi(_res2);
        }
        break;
    }
    Py_XDECREF(_res2);
    PyGILState_Release(gilstate);
    _res;
})
"""

def get_definition(name, use_name):
    if name in returns["pyobject"]:
        t = pyobject_return.replace("PySet_New", use_name)
    elif name in returns["no_gil"]:
        t = return_no_gil.replace("sqlite3_threadsafe", use_name)
    elif name in returns["with_gil"]:
        t = return_with_gil.replace("PyType_Ready", use_name)
    else:
        print("unknown template " + name)
        breakpoint()
        1 / 0
    t = t.strip().split("\n")
    maxlen = max(len(l) for l in t)
    for i in range(len(t) - 1):
        t[i] += " " * (maxlen - len(t[i])) + " \\\n"
    return "".join(t)

def genfile(symbols):
    res = []
    res.append(f"""\
/*  DO NOT EDIT THIS FILE
    This file is generated by tools/genfaultinject.py
    Edit that not this */
#ifdef APSW_TESTFIXTURES

#ifndef APSW_FAULT_INJECT_INCLUDED
{ proto }
#define APSW_FAULT_INJECT_INCLUDED
#endif

#ifdef APSW_FAULT_CLEAR
""")
    for s in sorted(symbols):
        res.append(f"#undef { s }")
    res.append("\n#else\n")
    for s in sorted(symbols):
        if s in call_map:
            res.append(f"#undef {s}")
        res.append(f"#define {s}(...) \\\n{ get_definition( s, call_map.get(s, s)) }")
    res.append("#endif")
    res.append("#endif")
    return "\n".join(res)


returns = {
    # these have the gil and return NULL on failure
    "pyobject": """
            PySet_New convert_value_to_pyobject getfunctionargs PyModule_Create2 PyErr_NewExceptionWithDoc
            PyUnicode_New  PyUnicode_AsUTF8 PyObject_GetAttrString _PyObject_New PyUnicode_FromString
            PyObject_Str PyUnicode_AsUTF8AndSize PyTuple_New PyDict_New Py_BuildValue PyList_New
            PyWeakref_NewRef PyMem_Calloc convertutf8string PyLong_FromLong PyObject_GetIter
            PyObject_CallObject PyIter_Next apsw_strdup PyLong_AsInt PyUnicode_FromStringAndSize
            PySequence_GetItem
            """.split(),
    # numeric return, no gil
    "no_gil": """
            sqlite3_threadsafe sqlite3_close sqlite3_db_config sqlite3_enable_shared_cache
            sqlite3_set_authorizer sqlite3_collation_needed
            sqlite3_enable_load_extension sqlite3_busy_handler sqlite3_value_type
            sqlite3_column_type sqlite3_status64 sqlite3_initialize sqlite3_shutdown
            """.split(),
    # py functions that return a number to indicate failure
    "with_gil": """
        PyType_Ready PyModule_AddObject PyModule_AddIntConstant PyLong_AsLong
        PyLong_AsLongLong PyObject_GetBuffer PyList_Append PyDict_SetItemString
        """.split(),
}

# some calls like Py_BuildValue are #defined to _Py_BuildValue_SizeT
# so deal with that here
call_map = {
    "Py_BuildValue": "_Py_BuildValue_SizeT",

}

# double check no dupes
for k, v in returns.items():
    if len(set(v)) != len(v):
        seen = set()
        for val in v:
            if val in seen:
                print(f"Duplicate item { val } in { k }")
            else:
                seen.add(val)
        sys.exit(1)


if __name__ == '__main__':
    import sys
    all = set()
    for v in returns.values():
        all.update(v)
    r = genfile(all)
    open(sys.argv[1], "wt").write(r)