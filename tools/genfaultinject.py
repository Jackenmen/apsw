#!/usr/bin/python

proto = """
static int
APSW_FaultInjectControl(const char *faultfunction, const char *filename, const char *funcname, int linenum, const char *args, PyObject **obj);
"""

pyobject_return = """
({
    PyObject *_res = 0;
    PyGILState_STATE gilstate = PyGILState_Ensure();
    switch (APSW_FaultInjectControl("PySet_New", __FILE__, __func__, __LINE__, #__VA_ARGS__, &_res))
    {
    case 0x1FACADE:
        assert(_res == 0);
        _res = PySet_New(__VA_ARGS__);
        break;
    default:
        assert(_res || PyErr_Occurred());
        assert(!(_res && PyErr_Occurred()));
        break;
    }
    PyGILState_Release(gilstate);
    _res;
})
"""

# for int returns, the fault injection can either return a number
# (PyLong) or a tuple(PyLong, AType, str) in which case
# PyErr_Format(AType, "%s", str) sets Python exception indicator and
# the PyLong is returned


# note this releases the gil around calls.
int_return_no_gil = """
({
    PyObject *_res2 = 0;
    int _res = 0;
    PyGILState_STATE gilstate = PyGILState_Ensure();
    switch (APSW_FaultInjectControl("sqlite3_threadsafe", __FILE__, __func__, __LINE__, #__VA_ARGS__, &_res2))
    {
    case 0x1FACADE:
        assert(_res2 == 0);
        PyGILState_Release(gilstate);
        _res = sqlite3_threadsafe(__VA_ARGS__);
        gilstate = PyGILState_Ensure();
        break;
    default:
        assert(_res2);
        if(PyTuple_Check(_res2))
        {
            assert(3 == PyTuple_GET_SIZE(_res2));
            _res = PyLong_AsLong(PyTuple_GET_ITEM(_res2, 0));
            assert(PyUnicode_Check(PyTuple_GET_ITEM(_res2, 2)));
            PyErr_Format(PyTuple_GET_ITEM(_res2, 1), "%s", PyUnicode_AsUTF8(PyTuple_GET_ITEM(_res2, 2)));
        }
        else
        {
            assert(PyLong_Check(_res2));
            _res = PyLong_AsLong(_res2);
        }
        break;
    }
    Py_XDECREF(_res2);
    PyGILState_Release(gilstate);
    _res;
})
"""

int_return = """
({
    PyObject *_res2=0;
    int _res = 0;
    PyGILState_STATE gilstate = PyGILState_Ensure();
    switch (APSW_FaultInjectControl("PyType_Ready", __FILE__, __func__, __LINE__, #__VA_ARGS__, &_res2))
    {
    case 0x1FACADE:
        assert(_res == 0);
        _res = PyType_Ready(__VA_ARGS__);
        break;
    default:
        if(PyTuple_Check(_res2))
        {
            assert(3 == PyTuple_GET_SIZE(_res2));
            _res = PyLong_AsLong(PyTuple_GET_ITEM(_res2, 0));
            assert(PyUnicode_Check(PyTuple_GET_ITEM(_res2, 2)));
            PyErr_Format(PyTuple_GET_ITEM(_res2, 1), "%s", PyUnicode_AsUTF8(PyTuple_GET_ITEM(_res2, 2)));
        }
        else
        {
            assert(PyLong_Check(_res2));
            _res = PyLong_AsLong(_res2);
        }
        break;
    }
    Py_XDECREF(_res2);
    PyGILState_Release(gilstate);
    _res;
})
"""


def get_definition(s):
    if s in returns["pyobject"]:
        t = pyobject_return.replace("PySet_New", s)
    elif s in returns["int_no_gil"]:
        t = int_return_no_gil.replace("sqlite3_threadsafe", s)
    elif s in returns["int"]:
        t = int_return.replace("PyType_Ready", s)
    else:
        print("unknown template " + s)
        breakpoint()
        1 / 0
    t = t.strip().split("\n")
    maxlen = max(len(l) for l in t)
    for i in range(len(t) - 1):
        t[i] += " " * (maxlen - len(t[i])) + " \\\n"
    return "".join(t)


def genfile(symbols):
    res = []
    res.append(f"""\
/*  DO NOT EDIT THIS FILE
    This file is generated by tools/genfaultinject.py
    Edit that not this */
#ifdef APSW_TESTFIXTURES

#ifndef APSW_FAULT_INJECT_INCLUDED
{ proto }
#define APSW_FAULT_INJECT_INCLUDED
#endif

#ifdef APSW_FAULT_CLEAR
""")
    for s in sorted(symbols):
        res.append(f"#undef { s }")
    res.append("\n#else\n")
    for s in sorted(symbols):
        res.append(f"#define {s}(...) \\\n{ get_definition(s) }")
    res.append("#endif")
    res.append("#endif")
    return "\n".join(res)


returns = {
    "pyobject": "PySet_New convert_value_to_pyobject getfunctionargs PyModule_Create2 PyErr_NewExceptionWithDoc".split(),
    "int_no_gil": "sqlite3_threadsafe".split(),
    "int": "PyType_Ready PyModule_AddObject PyModule_AddIntConstant".split(),
}

if __name__ == '__main__':
    import sys
    all = set()
    for v in returns.values():
        all.update(v)
    r = genfile(all)
    open(sys.argv[1], "wt").write(r)